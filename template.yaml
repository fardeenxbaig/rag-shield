AWSTemplateFormatVersion: '2010-09-09'
Description: 'Poisoned RAG Quarantine - Flexible deployment with Single or Dual bucket modes'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Deployment Configuration"
        Parameters:
          - DeploymentMode
          - CreateBedrockKB
      - Label:
          default: "Security Configuration"
        Parameters:
          - GuardrailId
          - AlertEmail
      - Label:
          default: "Resource Naming (Optional)"
        Parameters:
          - RawDataBucketName
          - ForensicBucketName
          - KBIngestionBucketName
          - LambdaFunctionName
          - DynamoDBTableName
          - SNSTopicName
      - Label:
          default: "Knowledge Base Configuration (Optional)"
        Parameters:
          - KnowledgeBaseName
          - EmbeddingModel

Parameters:
  DeploymentMode:
    Type: String
    Default: SingleBucket
    AllowedValues:
      - SingleBucket
      - DualBucket
    Description: |
      SingleBucket: Scan files in-place, KB reads from same bucket with ABAC (simpler, recommended).
      DualBucket: Scan in staging bucket, copy clean files to separate KB bucket (isolated).
  
  CreateBedrockKB:
    Type: String
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
    Description: Automatically create Bedrock Knowledge Base
  
  GuardrailId:
    Type: String
    Description: Bedrock Guardrail ID (leave empty to auto-create)
    Default: ''
  
  GuardrailName:
    Type: String
    Default: ''
    Description: Custom name for Bedrock Guardrail (leave empty for auto-generated)
  
  AlertEmail:
    Type: String
    Description: Email address for security alerts
    Default: security-team@company.com
  
  KnowledgeBaseName:
    Type: String
    Default: RAG-Knowledge-Base
    Description: Name for Bedrock Knowledge Base (only if CreateBedrockKB=true)
  
  EmbeddingModel:
    Type: String
    Default: amazon.titan-embed-text-v2:0
    AllowedValues:
      - amazon.titan-embed-text-v2:0
      - amazon.titan-embed-text-v1
      - cohere.embed-english-v3
      - cohere.embed-multilingual-v3
    Description: Embedding model for Knowledge Base
  
  # Resource Naming Parameters (Optional)
  RawDataBucketName:
    Type: String
    Default: ''
    Description: Custom name for raw data bucket (leave empty for auto-generated name)
    AllowedPattern: '^$|^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$'
    ConstraintDescription: Must be empty or valid S3 bucket name (lowercase, numbers, hyphens)
  
  ForensicBucketName:
    Type: String
    Default: ''
    Description: Custom name for forensic bucket (leave empty for auto-generated name)
    AllowedPattern: '^$|^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$'
    ConstraintDescription: Must be empty or valid S3 bucket name (lowercase, numbers, hyphens)
  
  KBIngestionBucketName:
    Type: String
    Default: ''
    Description: Custom name for KB ingestion bucket - DualBucket mode only (leave empty for auto-generated)
    AllowedPattern: '^$|^[a-z0-9][a-z0-9-]{1,61}[a-z0-9]$'
    ConstraintDescription: Must be empty or valid S3 bucket name (lowercase, numbers, hyphens)
  
  LambdaFunctionName:
    Type: String
    Default: ''
    Description: Custom name for Lambda function (leave empty for auto-generated name)
    AllowedPattern: '^$|^[a-zA-Z0-9-_]{1,64}$'
    ConstraintDescription: Must be empty or valid Lambda function name
  
  DynamoDBTableName:
    Type: String
    Default: ''
    Description: Custom name for DynamoDB audit table (leave empty for auto-generated name)
    AllowedPattern: '^$|^[a-zA-Z0-9._-]{3,255}$'
    ConstraintDescription: Must be empty or valid DynamoDB table name
  
  SNSTopicName:
    Type: String
    Default: ''
    Description: Custom name for SNS alert topic (leave empty for auto-generated name)
    AllowedPattern: '^$|^[a-zA-Z0-9_-]{1,256}$'
    ConstraintDescription: Must be empty or valid SNS topic name

Conditions:
  IsSingleBucket: !Equals [!Ref DeploymentMode, 'SingleBucket']
  IsDualBucket: !Equals [!Ref DeploymentMode, 'DualBucket']
  ShouldCreateKB: !Equals [!Ref CreateBedrockKB, 'true']
  HasGuardrailId: !Not [!Equals [!Ref GuardrailId, '']]
  ShouldCreateGuardrail: !Equals [!Ref GuardrailId, '']
  HasCustomRawBucket: !Not [!Equals [!Ref RawDataBucketName, '']]
  HasCustomForensicBucket: !Not [!Equals [!Ref ForensicBucketName, '']]
  HasCustomKBBucket: !Not [!Equals [!Ref KBIngestionBucketName, '']]
  HasCustomLambdaName: !Not [!Equals [!Ref LambdaFunctionName, '']]
  HasCustomTableName: !Not [!Equals [!Ref DynamoDBTableName, '']]
  HasCustomTopicName: !Not [!Equals [!Ref SNSTopicName, '']]
  HasCustomGuardrailName: !Not [!Equals [!Ref GuardrailName, '']]

Resources:
  # ============================================================================
  # BEDROCK GUARDRAIL
  # ============================================================================
  
  BedrockGuardrail:
    Type: AWS::Bedrock::Guardrail
    Condition: ShouldCreateGuardrail
    Properties:
      Name: !If 
        - HasCustomGuardrailName
        - !Ref GuardrailName
        - !Sub '${AWS::StackName}-Guardrail'
      BlockedInputMessaging: "Content blocked: Potential prompt injection detected"
      BlockedOutputsMessaging: "Response blocked: Security policy violation"
      Description: "Detects and blocks prompt injection attacks in RAG pipeline"
      ContentPolicyConfig:
        FiltersConfig:
          - Type: PROMPT_ATTACK
            InputStrength: HIGH
            OutputStrength: NONE
      Tags:
        - Key: Purpose
          Value: RAG Security
        - Key: ManagedBy
          Value: CloudFormation

  # ============================================================================
  # S3 BUCKETS
  # ============================================================================
  
  # Raw Data / Staging Bucket (always created)
  RawDataBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If 
        - HasCustomRawBucket
        - !Ref RawDataBucketName
        - !Sub '${AWS::StackName}-raw-data-${AWS::AccountId}'
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Purpose
          Value: Document Scanning
        - Key: Mode
          Value: !Ref DeploymentMode

  # KB Ingestion Bucket (only for DualBucket mode)
  KBIngestionBucket:
    Type: AWS::S3::Bucket
    Condition: IsDualBucket
    Properties:
      BucketName: !If 
        - HasCustomKBBucket
        - !Ref KBIngestionBucketName
        - !Sub '${AWS::StackName}-kb-ingestion-${AWS::AccountId}'
    Properties:
      BucketName: !Sub '${AWS::StackName}-kb-ingestion-${AWS::AccountId}'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Purpose
          Value: Clean Documents for KB

  # Forensic Bucket (always created)
  ForensicBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !If 
        - HasCustomForensicBucket
        - !Ref ForensicBucketName
        - !Sub '${AWS::StackName}-forensic-${AWS::AccountId}'
      ObjectLockEnabled: true
      ObjectLockConfiguration:
        ObjectLockEnabled: Enabled
        Rule:
          DefaultRetention:
            Mode: GOVERNANCE
            Days: 90
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
      Tags:
        - Key: Purpose
          Value: Quarantine Storage

  # ============================================================================
  # S3 BUCKET POLICIES
  # ============================================================================
  
  # ABAC Policy for SingleBucket mode
  RawDataBucketPolicySingleBucket:
    Type: AWS::S3::BucketPolicy
    Condition: IsSingleBucket
    Properties:
      Bucket: !Ref RawDataBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: DenyUnscannedIngestion
            Effect: Deny
            Principal:
              Service: bedrock.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub '${RawDataBucket.Arn}/*'
            Condition:
              StringNotEquals:
                s3:ExistingObjectTag/ScanStatus: Clean

  # ============================================================================
  # LAMBDA FUNCTION
  # ============================================================================
  
  ScannerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ScannerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:PutObjectTagging
                  - s3:GetObjectTagging
                Resource:
                  - !Sub '${RawDataBucket.Arn}/*'
                  - !Sub '${ForensicBucket.Arn}/*'
                  - !If
                    - IsDualBucket
                    - !Sub '${KBIngestionBucket.Arn}/*'
                    - !Ref AWS::NoValue
              - Effect: Allow
                Action:
                  - bedrock:ApplyGuardrail
                Resource: '*'
              - Effect: Allow
                Action:
                  - securityhub:BatchImportFindings
                Resource: '*'
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource: !Ref AlertTopic
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt AuditTable.Arn

  Scanner:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If 
        - HasCustomLambdaName
        - !Ref LambdaFunctionName
        - !Sub '${AWS::StackName}-Scanner'
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt ScannerRole.Arn
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          AUDIT_TABLE_NAME: !Ref AuditTable
          FORENSIC_BUCKET_NAME: !Ref ForensicBucket
          SNS_TOPIC_ARN: !Ref AlertTopic
          GUARDRAIL_ID: !If
            - HasGuardrailId
            - !Ref GuardrailId
            - !GetAtt BedrockGuardrail.GuardrailId
          GUARDRAIL_VERSION: DRAFT
          DEPLOYMENT_MODE: !Ref DeploymentMode
          KB_INGESTION_BUCKET: !If
            - IsDualBucket
            - !Ref KBIngestionBucket
            - ''
      Code:
        ZipFile: |
          import json, boto3, os, hashlib, logging
          from datetime import datetime
          from io import BytesIO
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          s3 = boto3.client('s3')
          bedrock = boto3.client('bedrock-runtime')
          securityhub = boto3.client('securityhub')
          sns = boto3.client('sns')
          dynamodb = boto3.resource('dynamodb')
          
          AUDIT_TABLE = dynamodb.Table(os.environ['AUDIT_TABLE_NAME'])
          FORENSIC_BUCKET = os.environ['FORENSIC_BUCKET_NAME']
          SNS_TOPIC = os.environ.get('SNS_TOPIC_ARN')
          GUARDRAIL_ID = os.environ.get('GUARDRAIL_ID')
          GUARDRAIL_VERSION = os.environ.get('GUARDRAIL_VERSION', 'DRAFT')
          DEPLOYMENT_MODE = os.environ.get('DEPLOYMENT_MODE', 'SingleBucket')
          KB_INGESTION_BUCKET = os.environ.get('KB_INGESTION_BUCKET', '')
          
          def lambda_handler(event, context):
              scan_id = context.aws_request_id
              logger.info(f"Scan started - ID: {scan_id}, Mode: {DEPLOYMENT_MODE}")
              
              try:
                  bucket = event['detail']['bucket']['name']
                  key = event['detail']['object']['key']
                  logger.info(f"Processing: s3://{bucket}/{key}")
                  
                  # Download file
                  obj = s3.get_object(Bucket=bucket, Key=key)
                  content = obj['Body'].read()
                  
                  # Extract text
                  try:
                      text = content.decode('utf-8')
                  except:
                      text = str(content)
                  
                  # Scan with Bedrock Guardrails
                  response = bedrock.apply_guardrail(
                      guardrailIdentifier=GUARDRAIL_ID,
                      guardrailVersion=GUARDRAIL_VERSION,
                      source='INPUT',
                      content=[{'text': {'text': text}}]
                  )
                  
                  action = response.get('action', 'NONE')
                  is_malicious = action == 'GUARDRAIL_INTERVENED'
                  status = 'Malicious' if is_malicious else 'Clean'
                  
                  logger.info(f"Scan result: {status}")
                  
                  # Tag file
                  s3.put_object_tagging(
                      Bucket=bucket,
                      Key=key,
                      Tagging={'TagSet': [
                          {'Key': 'ScanStatus', 'Value': status},
                          {'Key': 'ScanTimestamp', 'Value': datetime.utcnow().isoformat()},
                          {'Key': 'ScanId', 'Value': scan_id}
                      ]}
                  )
                  
                  # Handle malicious files
                  if is_malicious:
                      # Quarantine
                      date_path = datetime.utcnow().strftime('%Y/%m/%d')
                      forensic_key = f"quarantine/{date_path}/{scan_id}/{key}"
                      s3.copy_object(
                          CopySource={'Bucket': bucket, 'Key': key},
                          Bucket=FORENSIC_BUCKET,
                          Key=forensic_key
                      )
                      
                      # Security Hub finding
                      try:
                          securityhub.batch_import_findings(Findings=[{
                              'SchemaVersion': '2018-10-08',
                              'Id': f"rag-scanner/{scan_id}",
                              'ProductArn': f"arn:aws:securityhub:{os.environ['AWS_REGION']}:{context.invoked_function_arn.split(':')[4]}:product/{context.invoked_function_arn.split(':')[4]}/default",
                              'GeneratorId': 'poisoned-rag-scanner',
                              'AwsAccountId': context.invoked_function_arn.split(':')[4],
                              'Types': ['Software and Configuration Checks/Vulnerabilities/Prompt Injection'],
                              'CreatedAt': datetime.utcnow().isoformat() + 'Z',
                              'UpdatedAt': datetime.utcnow().isoformat() + 'Z',
                              'Severity': {'Label': 'HIGH'},
                              'Title': 'Prompt Injection Detected in RAG Document',
                              'Description': f"Malicious content detected in {key}",
                              'Resources': [{'Type': 'AwsS3Object', 'Id': f"arn:aws:s3:::{bucket}/{key}"}],
                              'Workflow': {'Status': 'NEW'}
                          }])
                      except Exception as e:
                          logger.error(f"Security Hub error: {e}")
                      
                      # SNS alert
                      if SNS_TOPIC:
                          try:
                              sns.publish(
                                  TopicArn=SNS_TOPIC,
                                  Subject='ðŸš¨ Malicious Document Detected',
                                  Message=f"File: {key}\nBucket: {bucket}\nScan ID: {scan_id}\nQuarantined: s3://{FORENSIC_BUCKET}/{forensic_key}"
                              )
                          except Exception as e:
                              logger.error(f"SNS error: {e}")
                  
                  # DualBucket: Copy clean files to KB bucket
                  elif DEPLOYMENT_MODE == 'DualBucket' and KB_INGESTION_BUCKET:
                      s3.copy_object(
                          CopySource={'Bucket': bucket, 'Key': key},
                          Bucket=KB_INGESTION_BUCKET,
                          Key=key
                      )
                      logger.info(f"Copied to KB bucket: {KB_INGESTION_BUCKET}/{key}")
                  
                  # Audit log
                  AUDIT_TABLE.put_item(Item={
                      'scan_id': scan_id,
                      'timestamp': datetime.utcnow().isoformat(),
                      'bucket': bucket,
                      'key': key,
                      'status': status,
                      'is_malicious': is_malicious,
                      'deployment_mode': DEPLOYMENT_MODE,
                      'guardrail_action': action
                  })
                  
                  return {'statusCode': 200, 'body': json.dumps({'status': status, 'scan_id': scan_id})}
                  
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  raise

  # ============================================================================
  # EVENTBRIDGE RULE
  # ============================================================================
  
  S3UploadRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Trigger scanner on S3 uploads
      EventPattern:
        source:
          - aws.s3
        detail-type:
          - Object Created
        detail:
          bucket:
            name:
              - !Ref RawDataBucket
      State: ENABLED
      Targets:
        - Arn: !GetAtt Scanner.Arn
          Id: ScannerTarget

  ScannerInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref Scanner
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt S3UploadRule.Arn

  # ============================================================================
  # DYNAMODB TABLE
  # ============================================================================
  
  AuditTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !If 
        - HasCustomTableName
        - !Ref DynamoDBTableName
        - !Sub '${AWS::StackName}-AuditLog'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: scan_id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: scan_id
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      Tags:
        - Key: Purpose
          Value: Audit Trail

  # ============================================================================
  # SNS TOPIC
  # ============================================================================
  
  AlertTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !If 
        - HasCustomTopicName
        - !Ref SNSTopicName
        - !Sub '${AWS::StackName}-Alerts'
      DisplayName: Poisoned RAG Security Alerts

  AlertEmailSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: email
      TopicArn: !Ref AlertTopic
      Endpoint: !Ref AlertEmail

  # ============================================================================
  # BEDROCK KNOWLEDGE BASE (Optional)
  # ============================================================================
  
  KnowledgeBaseRole:
    Type: AWS::IAM::Role
    Condition: ShouldCreateKB
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: KBPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !If
                    - IsSingleBucket
                    - !GetAtt RawDataBucket.Arn
                    - !GetAtt KBIngestionBucket.Arn
                  - !If
                    - IsSingleBucket
                    - !Sub '${RawDataBucket.Arn}/*'
                    - !Sub '${KBIngestionBucket.Arn}/*'

Outputs:
  DeploymentMode:
    Description: Deployment mode selected
    Value: !Ref DeploymentMode
  
  RawDataBucketName:
    Description: Raw data / staging bucket name
    Value: !Ref RawDataBucket
    Export:
      Name: !Sub '${AWS::StackName}-RawDataBucket'
  
  KBIngestionBucketName:
    Condition: IsDualBucket
    Description: KB ingestion bucket name (DualBucket mode only)
    Value: !Ref KBIngestionBucket
    Export:
      Name: !Sub '${AWS::StackName}-KBIngestionBucket'
  
  ForensicBucketName:
    Description: Forensic quarantine bucket name
    Value: !Ref ForensicBucket
  
  LambdaFunctionName:
    Description: Scanner Lambda function name
    Value: !Ref Scanner
  
  AuditTableName:
    Description: DynamoDB audit table name
    Value: !Ref AuditTable
  
  SNSTopicArn:
    Description: SNS alert topic ARN
    Value: !Ref AlertTopic
  
  UsageInstructions:
    Description: How to use this deployment
    Value: !If
      - IsSingleBucket
      - !Sub 'SingleBucket Mode: Upload documents to ${RawDataBucket}. Configure Bedrock KB to read from same bucket. ABAC policy enforces tag-based access.'
      - !Sub 'DualBucket Mode: Upload documents to ${RawDataBucket}. Clean files auto-copied to ${KBIngestionBucket}. Configure Bedrock KB to read from KB bucket.'
